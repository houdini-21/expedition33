import {
  Inject,
  Injectable,
  BadRequestException,
  UnauthorizedException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { google, Auth } from 'googleapis';
import { ACCOUNT_REPOSITORY } from '@domain/repository/account.repository';
import type { IAccountRepository } from '@domain/repository/account.repository';
import { IGoogleCalendarPort } from '@app/ports/google-calendar.port';

@Injectable()
export class GoogleCalendarService implements IGoogleCalendarPort {
  private oauth?: Auth.OAuth2Client;

  constructor(
    @Inject(ACCOUNT_REPOSITORY)
    private readonly accounts: IAccountRepository,
    private readonly config: ConfigService,
  ) {}

  /**
   * The function `getOauthClient` retrieves or creates an OAuth2Client using Google credentials from
   * configuration.
   * @returns The `getOauthClient` method returns an instance of `Auth.OAuth2Client` after checking and
   * initializing the OAuth client with the Google client ID, client secret, and callback URL from the
   * configuration. If the OAuth client has already been initialized, it returns the existing instance
   * stored in the `oauth` property.
   */
  private getOauthClient(): Auth.OAuth2Client {
    if (this.oauth) return this.oauth;

    const cid = this.config.get<string>('GOOGLE_CLIENT_ID') || '';
    const sec = this.config.get<string>('GOOGLE_CLIENT_SECRET') || '';
    const cb = this.config.get<string>('GOOGLE_CALENDAR_CALLBACK_URL') || '';
    if (!cid || !sec || !cb) {
      throw new Error(
        'Missing GOOGLE_CLIENT_ID / GOOGLE_CLIENT_SECRET / GOOGLE_CALENDAR_CALLBACK_URL in configuration',
      );
    }
    this.oauth = new google.auth.OAuth2(cid, sec, cb);
    return this.oauth;
  }

  /**
   * The function `getAuthUrl` generates an authorization URL for a specific user ID with specified
   * scopes and parameters.
   * @param {string} userId - The `userId` parameter is a string that represents the unique identifier of
   * a user. It is used to generate the authorization URL for the user to grant access to specific scopes
   * for the Google Calendar API.
   * @returns The `getAuthUrl` function returns a URL that is generated by the OAuth client with specific
   * parameters such as access type, prompt, scope, and state. This URL is used for authentication and
   * authorization purposes, typically for accessing Google Calendar data with read-only permissions.
   */
  getAuthUrl(userId: string): string {
    if (!userId) throw new BadRequestException('userId requerido');
    const oauth = this.getOauthClient();
    return oauth.generateAuthUrl({
      access_type: 'offline',
      prompt: 'consent',
      scope: [
        'https://www.googleapis.com/auth/calendar.readonly',
        'openid',
        'email',
        'profile',
      ],
      state: userId,
    });
  }

  /**
   * The function `handleCallback` processes a callback by exchanging a code for tokens and updating
   * Google tokens for a specific user.
   * @param {string} code - The `code` parameter is typically a unique authorization code that is
   * generated by an OAuth 2.0 authorization server and is used in the authorization flow to exchange for
   * access tokens. It is a temporary code that the client application receives after the user grants
   * permission to access their data.
   * @param {string} stateUserId - The `stateUserId` parameter in the `handleCallback` function is a
   * string that represents the user ID associated with the state of the OAuth flow. It is used to ensure
   * that the callback response is associated with the correct user and to maintain the state of the
   * authentication process.
   */
  async handleCallback(code: string, stateUserId: string): Promise<void> {
    if (!code || !stateUserId)
      throw new BadRequestException('code/state faltantes en callback');
    const oauth = this.getOauthClient();
    const { tokens } = await oauth.getToken(code);

    await this.accounts.updateGoogleTokens({
      userId: stateUserId,
      providerAccountId: stateUserId,
      accessToken: tokens.access_token ?? null,
      refreshToken: tokens.refresh_token ?? undefined,
      expiresAt: tokens.expiry_date ? new Date(tokens.expiry_date) : null,
    });
  }

  /**
   * The function `postConnectRedirect` returns the value of the environment variable
   * `APP_POST_CONNECT_REDIRECT` or '/' if it is not set.
   * @returns The `postConnectRedirect` property is being returned. It retrieves the value of the
   * `APP_POST_CONNECT_REDIRECT` configuration variable from the application configuration, or defaults
   * to `'/'` if the configuration variable is not set.
   */
  get postConnectRedirect(): string {
    return this.config.get<string>('APP_POST_CONNECT_REDIRECT') || '/';
  }

  /**
   * The `isConnected` function in TypeScript checks if a user is connected to Google.
   * @param {string} userId - The `userId` parameter is a string that represents the unique identifier of
   * a user.
   * @returns The `isConnected` function is returning a Promise that resolves to a boolean value
   * indicating whether the user with the specified `userId` is connected to Google.
   */
  async isConnected(userId: string): Promise<boolean> {
    return this.accounts.isGoogleConnected(userId);
  }

  /**
   * The function `authFor` retrieves Google OAuth2 client with credentials for a specific user.
   * @param {string} userId - The `userId` parameter in the `authFor` function is a string that
   * represents the unique identifier of the user for whom the authentication is being performed.
   * @returns The `authFor` function is returning a Promise that resolves to an instance of
   * `Auth.OAuth2Client`.
   */
  private async authFor(userId: string): Promise<Auth.OAuth2Client | null> {
    const oauth = this.getOauthClient();
    const creds = await this.accounts.getGoogleTokens(userId);
    if (!creds?.refreshToken) {
      return null;
    }

    oauth.setCredentials({
      access_token: creds.accessToken ?? undefined,
      refresh_token: creds.refreshToken ?? undefined,
      expiry_date: creds.expiresAt
        ? new Date(creds.expiresAt).getTime()
        : undefined,
    });
    return oauth;
  }
  /**
   * The function `hasBusy` checks if a user is busy within a specified time range by querying their
   * Google Calendar events.
   * @param {string} userId - The `userId` parameter in the `hasBusy` function represents the unique
   * identifier of the user for whom you want to check the busy status in their calendar.
   * @param {Date} start - The `start` parameter is a `Date` object representing the start time for
   * checking the user's busy status.
   * @param {Date} end - The `end` parameter in the `hasBusy` function represents the end date and time
   * for which you want to check the user's availability. This parameter is of type `Date` and is used to
   * specify the upper limit of the time range within which you want to check for the user's busy
   * @returns The `hasBusy` function returns a Promise that resolves to a boolean value. The boolean
   * value indicates whether the user with the specified `userId` is busy within the time range specified
   * by the `start` and `end` parameters.
   */

  async hasBusy(userId: string, start: Date, end: Date): Promise<boolean> {
    const auth = await this.authFor(userId);

    if (!auth) return false;

    const cal = google.calendar({ version: 'v3', auth });

    const res = await cal.freebusy.query({
      requestBody: {
        timeMin: start.toISOString(),
        timeMax: end.toISOString(),
        items: [{ id: 'primary' }],
      },
    });

    const busy = res.data.calendars?.primary?.busy ?? [];
    return busy.length > 0;
  }
}
